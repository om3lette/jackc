#include "code_gen.h"
#include "common/jackc_assert.h"
#include "jackc_stdio.h"
#include "jackc_string.h"
#include "vm-translator/code-generation/utils.h"
#include "vm-translator/constants.h"
#include "vm-translator/parser.h"
#include <stdint.h>

void jackc_vm_code_bootstrap(vm_code_generator* generator) {
    int fd = generator->fd;
    VM_CODE_GEN_HELP_COMMENT(fd, "Bootstrap code\n", 0);
    // If vm code does not contain a function call than LCL a.k.a frame pointer
    // is never initialized, causing invalid read / write.
    //
    // This enables support for vm code with no function calls.
    // (mainly for nand2tetris compatibility and testing purposes).
    jackc_fprintf(fd,"mv %s, sp\n", SEGMENT_LCL_REG);

    // Iniitialize static variables base address
    // STATIC_BASE_LABEL itself will be generated by `jackc_vm_code_gen_finalize`
    jackc_fprintf(fd, "la %s, %s\n", SEGMENT_STATIC_REG, STATIC_BASE_LABEL);

    // If stack pointer register is sp there is no need to initialize it
    if (jackc_strcmp(JACK_SP_REG, "sp") != 0) {
        jackc_fprintf(fd, "mv %s, sp\n", JACK_SP_REG);
    };

    jackc_fprintf(fd, "\n");
}

void vm_code_gen_stack_alloc(int fd, int words) {
    jackc_fprintf(fd, "\taddi %s, %s, -%d\n", JACK_SP_REG, JACK_SP_REG, word_to_bytes(words));
}

void vm_code_gen_stack_dealloc(int fd, int words) {
    jackc_fprintf(fd, "\taddi %s, %s, %d\n", JACK_SP_REG, JACK_SP_REG, word_to_bytes(words));
}

void vm_code_gen_push(int fd, jackc_vm_segment_type type, int idx) {
    VM_CODE_GEN_HELP_COMMENT_TAB(fd, "push %s %d\n", vm_segment_type_to_string(type), idx);
    vm_code_gen_stack_alloc(fd, 1);

    long byte_offset = word_to_bytes(idx);
    char* reg = NULL;

    // Handle segments that use base-pointer + offset logic
    switch (type) {
        case SEGMENT_THIS:
            reg = SEGMENT_THIS_REG;
            break;
        case SEGMENT_THAT:
            reg = SEGMENT_THAT_REG;
            break;
        case SEGMENT_ARG:
            reg = SEGMENT_ARG_REG;
            break;
        case SEGMENT_LOCAL:
            reg = SEGMENT_LCL_REG;
            break;
        case SEGMENT_STATIC:
            reg = SEGMENT_STATIC_REG;
            break;
        default:
            reg = NULL;
    }
    if (reg) {
        jackc_fprintf(
            fd,
            "\tlw %s, -%d(%s)\n"
            "\tsw %s, 0(%s)\n",
            LOAD_REG, byte_offset, reg,
            LOAD_REG, JACK_SP_REG
        );
        return;
    }

    // Handle segments that don't use base-pointer + offset logic
    switch (type) {
        case SEGMENT_CONSTANT:
            jackc_fprintf(
                fd,
                "\tli %s, %d\n"
                "\tsw %s, 0(%s)\n",
                LOAD_REG, idx,
                LOAD_REG, JACK_SP_REG
            );
            break;
        case SEGMENT_POINTER: {
            jackc_assert((idx == POINTER_THIS || idx == POINTER_THAT) && "Invalid pointer argument");

            char* segment_reg = idx == POINTER_THIS ? SEGMENT_THIS_REG : SEGMENT_THAT_REG;
            jackc_fprintf(
                fd,
                "\tlw %s, -%d(%s)\n"
                "\tsw %s, 0(%s)\n",
                LOAD_REG, byte_offset, segment_reg,
                LOAD_REG, JACK_SP_REG
            );
            break;
        }
        case SEGMENT_TEMP:
            jackc_assert(idx >= 0 && idx < 8 && "Invalid temp index (must be 0â€“7).");
            jackc_fprintf(fd, "\tsw t%d, 0(%s)\n", idx, JACK_SP_REG);
            break;
        default:
            jackc_assert(false && "Unhandled segment type in push operation.");
    }
}

void vm_code_gen_pop(int fd, jackc_vm_segment_type type, int idx) {
    jackc_assert(type != SEGMENT_CONSTANT && "pop with constant segment is not allowed");

    VM_CODE_GEN_HELP_COMMENT_TAB(fd, "pop %s %d\n", vm_segment_type_to_string(type), idx);

    long byte_offset = word_to_bytes(idx);
    char* reg = NULL;

    // Handle segments that use base-pointer + offset logic
    switch (type) {
        case SEGMENT_THIS:
            reg = SEGMENT_THIS_REG;
            break;
        case SEGMENT_THAT:
            reg = SEGMENT_THAT_REG;
            break;
        case SEGMENT_ARG:
            reg = SEGMENT_ARG_REG;
            break;
        case SEGMENT_LOCAL:
            reg = SEGMENT_LCL_REG;
            break;
        case SEGMENT_STATIC:
            reg = SEGMENT_STATIC_REG;
            break;
        default:
            reg = NULL;
    }
    if (reg) {
        jackc_fprintf(
            fd,
            "\tsw %s, 0(%s)\n"
            "\tlw %s, -%d(%s)\n",
            LOAD_REG, byte_offset, reg,
            LOAD_REG, JACK_SP_REG
        );
        vm_code_gen_stack_dealloc(fd, 1);
        return;
    }

    switch (type) {
        case SEGMENT_TEMP:
            jackc_assert(idx >= 0 && idx < 7 && "Invalid temp index.");
            jackc_fprintf(fd, "\tlw t%d, 0(%s)\n", idx, JACK_SP_REG);
            break;
        case SEGMENT_POINTER: {
            char* selected_register = (idx == POINTER_THIS) ? SEGMENT_THIS_REG : SEGMENT_THAT_REG;
            jackc_fprintf(
                fd,
                "\tsw %s, 0(%s)\n",
                selected_register, JACK_SP_REG
            );
            break;
        }
        default:
            jackc_assert(false && "Unhandled segment type in pop operation.");
    }

    vm_code_gen_stack_dealloc(fd, 1);
}

void vm_code_gen_arithmetic_2_args(int fd, jackc_vm_cmd_type cmd) {
    vm_code_gen_pop(fd, SEGMENT_TEMP, OP_ARG_1_IDX);

    char op[4];
    switch (cmd) {
        case C_NEG:
            jackc_strcpy(op, "neg");
            break;
        case C_NOT:
            jackc_strcpy(op, "not");
            break;
        default:
            jackc_assert(false && "Invalid 2 argument arithmetic command");
            break;
    }
    jackc_fprintf(fd, "\t%s %s, %s\n", op, OP_RES_REG, OP_ARG_1_REG);
    vm_code_gen_push(fd, SEGMENT_TEMP, OP_RES_IDX);
}

/**
 * @todo: align assembly instructions
 */
void vm_code_gen_arithmetic_3_args(int fd, jackc_vm_cmd_type cmd) {
    // perf: allocation can be done in one command
    vm_code_gen_pop(fd, SEGMENT_TEMP, OP_ARG_2_IDX);
    vm_code_gen_pop(fd, SEGMENT_TEMP, OP_ARG_1_IDX);

    char op[4];
    switch (cmd) {
        case C_ADD:
            jackc_strcpy(op, "add");
            break;
        case C_SUB:
            jackc_strcpy(op, "sub");
            break;
        case C_AND:
            jackc_strcpy(op, "and");
            break;
        case C_OR:
            jackc_strcpy(op, "or");
            break;
        default:
            jackc_assert(false && "Invalid 3 argument arithmetic command");
            break;
    }
    jackc_fprintf(fd, "\t%s %s, %s, %s\n", op, OP_RES_REG, OP_ARG_1_REG, OP_ARG_2_REG);
    vm_code_gen_push(fd, SEGMENT_TEMP, OP_RES_IDX);
}

void vm_code_gen_return(int fd) {
    VM_CODE_GEN_HELP_COMMENT_TAB(fd, "Store the return value\n", 0);
    jackc_fprintf(fd, "\tlw %s, 0(%s)\n", RET_REG, JACK_SP_REG);
    VM_CODE_GEN_HELP_COMMENT_TAB(fd, "Restore the frame pointer\n", 0);
    jackc_fprintf(
        fd,
        "\taddi %s, %s, %d\n"
        "\tret\n",
        JACK_SP_REG, SEGMENT_LCL_REG, -word_to_bytes(1)
    );
}

void vm_code_gen_branching(int fd, jackc_vm_cmd_type cmd, const jackc_string* label) {
    switch (cmd) {
        case C_IF_GOTO:
            vm_code_gen_pop(fd, SEGMENT_TEMP, LOAD_IDX);
            jackc_fprintf(
                fd,
                "\tbne %s, x0, %.*s\n",
                LOAD_REG, label->length, label->data
            );
            break;
        case C_GOTO:
            jackc_fprintf(fd, "\tj %.*s\n", label->length, label->data);
            break;
        default:
            jackc_assert(false && "Invalid branching command");
            break;
    }
}

void vm_code_gen_label(int fd, const jackc_string* label) {
    jackc_fprintf(fd, "%.*s:\n", label->length, label->data);
}

/**
 * @todo: Add filename/index to function label
 */
void vm_code_gen_function(int fd, const jackc_string* name, int local_cnt) {
    jackc_fprintf(fd, "%s:\n", vm_code_gen_function_label(name));

    /**
     * Example stack layout with local_cnt = 2:
     * [sp+32] argument 0     | <- ARG ptr
     * [sp+28] argument 1     |
     * [sp+24] OLD_LCL        |
     * [sp+20] OLD_ARG        |
     * [sp+16] OLD_THAT       |
     * [sp+12] OLD_THIS       |
     * [sp+ 8] return address |
     * [sp+ 4] local arg 0    | <- LCL ptr
     * [sp+ 0] local arg 1    |
    */
    VM_CODE_GEN_HELP_COMMENT_TAB(fd, "Initialize LCL\n", 0);
    jackc_fprintf(
        fd,
        "\taddi %s, %s, 4\n",
        SEGMENT_LCL_REG, JACK_SP_REG
    );
    if (local_cnt > 0) {
        vm_code_gen_stack_alloc(fd, word_to_bytes(local_cnt));
    }
}

/**
 * Stack layout:
 * [sp+24] argument 0
 * [sp+20] argument 1
 * [sp+16] LCL
 * [sp+12] ARG
 * [sp+ 8] THAT
 * [sp+ 4] THIS
 * [sp+ 0] return address
*/
void vm_code_gen_call(int fd, const jackc_string* function_name, int arg_count) {
    VM_CODE_GEN_HELP_COMMENT_TAB(fd, "Save registers\n", 0);
    const int SAVED_REGISTERS = 5;
    vm_code_gen_stack_alloc(fd, SAVED_REGISTERS);
    jackc_fprintf(
        fd,
        "\tsw ra, 0(%s)\n"
        "\tsw %s, %d(%s)\n"
        "\tsw %s, %d(%s)\n"
        "\tsw %s, %d(%s)\n"
        "\tsw %s, %d(%s)\n",
        JACK_SP_REG,
        SEGMENT_THIS_REG, word_to_bytes(1), JACK_SP_REG,
        SEGMENT_THAT_REG, word_to_bytes(2), JACK_SP_REG,
        SEGMENT_ARG_REG, word_to_bytes(3), JACK_SP_REG,
        SEGMENT_LCL_REG, word_to_bytes(4), JACK_SP_REG
    );
    if (arg_count > 0) {
        VM_CODE_GEN_HELP_COMMENT_TAB(fd, "Set the ARG ptr\n", 0);
        jackc_fprintf(
            fd,
            "\taddi %s, %s, %d\n",
            SEGMENT_ARG_REG, JACK_SP_REG, word_to_bytes(SAVED_REGISTERS + arg_count - 1)
        );
    }

    // Make a function call
    jackc_fprintf(fd, "\tcall %s\n", vm_code_gen_function_label(function_name));

    VM_CODE_GEN_HELP_COMMENT_TAB(fd, "Restore registers\n", 0);
    jackc_fprintf(
        fd,
        "\tlw ra, 0(%s)\n"
        "\tlw %s, %d(%s)\n"
        "\tlw %s, %d(%s)\n"
        "\tlw %s, %d(%s)\n"
        "\tlw %s, %d(%s)\n",
        JACK_SP_REG,
        SEGMENT_THIS_REG, word_to_bytes(1), JACK_SP_REG,
        SEGMENT_THAT_REG, word_to_bytes(2), JACK_SP_REG,
        SEGMENT_ARG_REG, word_to_bytes(3), JACK_SP_REG,
        SEGMENT_LCL_REG, word_to_bytes(4), JACK_SP_REG
   );

   vm_code_gen_stack_dealloc(fd, SAVED_REGISTERS + arg_count - 1);
   // push the return value
   jackc_fprintf(fd, "\tsw %s, 0(%s)\n", RET_REG, JACK_SP_REG);
}

void vm_code_gen_comparisons(int fd, jackc_vm_cmd_type cmd) {
    vm_code_gen_pop(fd, SEGMENT_TEMP, OP_ARG_2_IDX);
    vm_code_gen_pop(fd, SEGMENT_TEMP, OP_ARG_1_IDX);

    switch (cmd) {
        case C_EQ:
            jackc_fprintf(fd,
                "\tsub %s, %s, %s\n"
                "\tseqz %s, %s\n",
                OP_RES_REG, OP_ARG_1_REG, OP_ARG_2_REG,
                OP_RES_REG, OP_RES_REG
            );
            break;
        case C_GT:
            jackc_fprintf(fd, "\tsgt %s, %s, %s\n", OP_RES_REG, OP_ARG_1_REG, OP_ARG_2_REG);
            break;
        case C_LT:
            jackc_fprintf(fd, "\tslt %s, %s, %s\n", OP_RES_REG, OP_ARG_1_REG, OP_ARG_2_REG);
            break;
        default:
            jackc_assert(false && "Invalid comparison command");
            break;
    }
    vm_code_gen_push(fd, SEGMENT_TEMP, OP_RES_IDX);
}

void jackc_vm_code_gen_line(vm_code_generator* generator, const jackc_parser* parser) {
    int fd = generator->fd;
    switch (parser->cmd) {
        case C_ADD:
        case C_SUB:
        case C_AND:
        case C_OR:
            vm_code_gen_arithmetic_3_args(fd, parser->cmd);
            break;
        case C_NEG:
        case C_NOT:
            vm_code_gen_arithmetic_2_args(fd, parser->cmd);
            break;
        case C_EQ:
        case C_GT:
        case C_LT:
            vm_code_gen_comparisons(fd, parser->cmd);
            break;
        case C_PUSH:
            if (parser->segment == SEGMENT_STATIC)
                vm_code_gen_update_static_idx(generator, (size_t)parser->arg2);
            vm_code_gen_push(fd, parser->segment, parser->arg2);
            break;
        case C_POP:
            if (parser->segment == SEGMENT_STATIC)
                vm_code_gen_update_static_idx(generator, (size_t)parser->arg2);
            vm_code_gen_pop(fd, parser->segment, parser->arg2);
            break;
        case C_FUNCTION:
            vm_code_gen_function(fd, &parser->arg1, parser->arg2);
            break;
        case C_LABEL:
            vm_code_gen_label(fd, &parser->arg1);
            break;
        case C_GOTO:
        case C_IF_GOTO:
            vm_code_gen_branching(fd, parser->cmd, &parser->arg1);
            break;
        case C_RETURN:
            vm_code_gen_return(fd);
            break;
        case C_CALL:
            vm_code_gen_call(fd, &parser->arg1, parser->arg2);
            break;
        case C_UNKNOWN:
            jackc_assert(false && "Unknown command found while generating code");
            break;
    }
}

void jackc_vm_code_gen_finalize(vm_code_generator* generator) {
    // 0 indexed, therefore +1
    int static_var_cnt = (int)generator->static_idx + 1;
    jackc_fprintf(
        generator->fd,
        "\n.data\n"
        "%s: .space %d\n",
        STATIC_BASE_LABEL, word_to_bytes(static_var_cnt)
    );

    // Add an empty line
    jackc_fprintf(generator->fd, "\n");
}
